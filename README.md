### Bridge

Implement the verification of Merkle proofs using Zero-Knowledge Proofs (ZKPs)

### Components

- Circuits
	- merkle_proof_verification.circom
	- get_merkle_root.circom

-  Contracts
	- Bridge
	- Merkle
### Build
requirement: [circom](https://docs.circom.io/getting-started/installation/)
version>=2.1.2
```
$ npm run build 
```
#### Compile circuits

```
$ cd circuit && ./run.sh main
```

### How it work

Mixer is built on `Groth16` and `Merkle Tree`.
* `./run.sh main`

This operation produces 4 files in circuit directory:
>* input.json : witness produced by the file scripts/generate.js, a sample is as below: 
```
{
    "root": "6006452839415899035733807029325942815929888768074345937414569668512067894100",
    "nullifierHash": "3701224944747537563701225775873437347582519438989321326160774689502152321319",
    "paths2_root": [
        3174904703,
        1831855034,
        2927866351,
        3904382600,
        4026780824,
        2259814112,
        3460561431,
        3054720229
    ],
    "paths2_root_pos": [
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1
    ]
}
```
where path2_root is generated by call `getMerkleProof`, and `root` is the merkle root, and `nullifierHash` is nullifier to check whether the commitment has been withdrawed. The secret is used to generate the commitment by hash function in binary format, paths2_root        is the salt for each non-leaf node to compute it's hash.  And paths2_root_pos is 0 or 1, used as a sign function to choose whether paths2_root as `xIn` and previous path2_root as `k`, and vice versa. The circom code shown as below:

```
merkle_root[v].x_in <== paths2_root[v] - paths2_root_pos[v] * (paths2_root[v] - merkle_root[v-1].out);
merkle_root[v].k<== merkle_root[v-1].out - paths2_root_pos[v]* (merkle_root[v-1].out - paths2_root[v]);
```

>* public.json: includes root.
>* proof.json: merkle proof.

* `npx hardhat node`

Start the local node.

* `npm run test`

Run the UT .